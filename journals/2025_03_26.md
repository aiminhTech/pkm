## Goals & Work
	- DONE Arbeitsjournal Montag 24.03 ergänzen
	- [[LRN-276: Data Delivery Explorer]]
		- **Reverse Proxy**
			- Ich habe gemeinsam mit Mike den Reverse Proxy verbessert.
			- Zuvor hatte ich auch die Stage-Information per POST-Methode im Formular mitgesendet. Diese Information wurde ursprünglich vom Proxy mitgeschickt, obwohl das Ziel-Backend sie gar nicht benötigte. Ich musste daher die Stage-Daten aus dem Request entfernen, um die Weiterleitung korrekt durchzuführen. Gleichzeitig benötige ich die Stage aber weiterhin, um die richtige API-URL innerhalb des Proxys dynamisch zu bestimmen.
			- Das hat die Logik im Proxy komplexer gemacht, insbesondere da ich ein Domain-Modell mit einem Effect-Schema verwende. Da der HTTP-Client ebenfalls auf der Effect-TS-Plattform basiert, musste ich sicherstellen, dass die Daten korrekt nach Schema geparst werden. Ohne eine gültige Parser-Definition schlägt der Request mit einem Schema-Fehler fehl.
			- Wir haben ihn so angepasst, dass er nur noch die API-Anfragen vom Frontend an das Backend weiterleitet. Der Stage-Daten haben wir aus dem Formular  entfernt. Stattdessen übergeben wir die Stage nun über die URL als Query-Parameter. Der Proxy kann diesen Parameter auslesen und basierend darauf die korrekte API-URL bestimmen, ohne dass der Backend-Request dadurch beeinflusst wird.
		- **RefreshToken Fix**
			- Die Refresh-Token-Logik funktioniert bisher nur ab und zu, da ich im `refreshToken`-Prozess noch überprüfe, ob die verbleibende Zeit des Tokens kleiner als 50% der ursprünglichen Refresh-Dauer ist. Falls ja, wird der Token tatsächlich refreshed.
			- Das Problem liegt darin, dass mein `setInterval` und die Zeitberechnung zu knapp bemessen sind. Wenn beim ersten Check die verbleibende Zeit noch grösser als 50% ist, wird beim zweiten Check der Zeitpunkt bereits überschritten sein, wodurch der Token nicht rechtzeitig erneuert wird. Ich muss den `setInterval`-Mechanismus und die Zeitberechnung anpassen, um sicherzustellen, dass der Token rechtzeitig erneuert wird, bevor er abläuft. Eine Lösung könnte sein, den `setInterval`-Wert anzupassen oder eine präzisere Berechnung der verbleibenden Zeit vorzunehmen, um die Logik zuverlässiger zu gestalten.
- ## Meeting
- ## Duties
- ## Learn
- ## Reflection
	-